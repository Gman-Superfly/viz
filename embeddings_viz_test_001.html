<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Embedding Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #0a0f1c;
            color: #c0c6d4;
        }

        #canvas { width: 100vw; height: 100vh; }

        .code-glass {
            background: rgba(20, 25, 40, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(60, 70, 100, 0.3);
            box-shadow: 0 0 15px rgba(80, 100, 255, 0.15),
                        inset 0 0 10px rgba(80, 100, 255, 0.05);
        }

        .btn-code {
            position: relative;
            overflow: hidden;
            transition: all 0.2s ease;
            background: #1e2636;
            color: #80a0ff;
        }

        .btn-code:hover {
            background: #2a3450;
            color: #a0c0ff;
        }

        .btn-code::before {
            content: '';
            position: absolute;
            top: -2px; left: -2px; right: -2px; bottom: -2px;
            background: linear-gradient(45deg, #5064ff, #80a0ff, #ff6080, #ffa060);
            background-size: 300% 300%;
            animation: gradient 4s ease infinite;
            border-radius: 8px;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: -1;
        }

        .btn-code:hover::before { opacity: 0.2; }

        .code-text {
            text-shadow: 0 0 4px rgba(80, 100, 255, 0.5);
            letter-spacing: 0.5px;
            font-family: 'Courier New', monospace;
        }

        .dark-grid {
            background-image: linear-gradient(rgba(80, 100, 255, 0.05) 1px, transparent 1px),
                            linear-gradient(90deg, rgba(80, 100, 255, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        ::-webkit-scrollbar {
            width: 4px;
            height: 4px;
        }

        ::-webkit-scrollbar-track { background: rgba(20, 25, 40, 0.5); }
        ::-webkit-scrollbar-thumb {
            background: #5064ff;
            border-radius: 4px;
        }
    </style>
</head>
<body class="font-mono text-sm antialiased">
    <div id="loading" class="fixed inset-0 flex items-center justify-center bg-black/90 z-50 transition-opacity duration-500">
        <div class="flex flex-col items-center gap-4">
            <div class="relative">
                <div class="w-12 h-12 border-2 border-transparent border-t-[#5064ff] border-r-[#80a0ff] rounded-full animate-spin"></div>
                <div class="absolute inset-0 w-12 h-12 border-2 border-[#5064ff]/20 rounded-full"></div>
            </div>
            <p class="text-lg tracking-wider code-text">BOOTING MATRIX</p>
            <div id="loading-progress" class="text-xs w-56 text-center opacity-75"></div>
        </div>
    </div>

    <div id="canvas" class="dark-grid"></div>

    <aside class="fixed top-2 left-2 w-72 p-4 code-glass rounded-lg z-20 transition-all duration-200">
        <h1 class="text-xl font-bold mb-3 code-text text-[#5064ff]">[ EMBEDDINGS CORE ]</h1>
        <div class="space-y-3">
            <div>
                <label class="block text-xs mb-1 opacity-80">INPUT STREAM</label>
                <textarea id="embedding-input" class="w-full h-28 p-2 bg-[#141928]/80 border border-[#5064ff]/20 rounded-md text-xs focus:outline-none focus:border-[#5064ff] resize-y text-[#80a0ff]" placeholder='{"type": "hack", "embedding": [0.1, 0.2, ...]}'></textarea>
            </div>
            <div class="flex gap-2">
                <button id="visualize-btn" class="flex-1 py-2 rounded-md btn-code">RUN</button>
                <button id="reset-btn" class="flex-1 py-2 rounded-md btn-code">WIPE</button>
            </div>
            <div class="code-glass p-2 rounded-md">
                <button id="settings-toggle" class="w-full py-2 bg-[#1e2636]/80 hover:bg-[#2a3450] rounded-md text-xs flex items-center justify-between btn-code">
                    <span>CONFIG</span>
                    <span id="settings-icon">▾</span>
                </button>
                <div id="settings-panel" class="mt-2 hidden space-y-2 p-1">
                    <div>
                        <label class="block text-xs mb-1 opacity-80">DROP SPEED</label>
                        <input type="range" id="speed-slider" min="1" max="10" value="5" class="w-full accent-[#5064ff]">
                    </div>
                    <div>
                        <label class="block text-xs mb-1 opacity-80">GLOW PULSE</label>
                        <input type="range" id="glow-slider" min="1" max="10" value="7" class="w-full accent-[#5064ff]">
                    </div>
                    <div>
                        <label class="block text-xs mb-1 opacity-80">THRESHOLD</label>
                        <input type="range" id="threshold-slider" min="1" max="10" value="5" class="w-full accent-[#5064ff]">
                        <div id="threshold-value" class="text-xs text-right opacity-60 mt-1">0.05</div>
                    </div>
                    <div class="flex items-center">
                        <input type="checkbox" id="pulse-checkbox" class="mr-2 accent-[#5064ff]">
                        <label class="text-xs opacity-80">PULSE MODE</label>
                    </div>
                </div>
            </div>
            <div class="code-glass p-2 rounded-md">
                <button id="sample-toggle" class="w-full py-2 bg-[#1e2636]/80 hover:bg-[#2a3450] rounded-md text-xs flex items-center justify-between btn-code">
                    <span>SAMPLE HACK</span>
                    <span id="toggle-icon">▾</span>
                </button>
                <div id="sample-panel" class="mt-2 hidden">
                    <div class="flex gap-2 mb-2">
                        <button id="generate-sample" class="flex-1 py-2 rounded-md btn-code">SPAWN</button>
                        <button id="shoot-btn" class="flex-1 py-2 rounded-md btn-code">FIRE</button>
                    </div>
                    <div id="stats" class="mt-2 text-xs text-[#80a0ff] p-2 border border-[#5064ff]/15 rounded-md"></div>
                </div>
            </div>
        </div>
    </aside>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/controls/OrbitControls.js"></script>
    <script>
        let scene, camera, renderer, controls, embeddings = [];
        let fallSpeed = 5;
        let glowIntensity = 7;
        let valueThreshold = 0.05;
        let pulseEffect = false;
        let cameraInitialized = false;
        let lastCameraPosition = { x: 0, y: 5, z: 10 };
        let lastCameraTarget = { x: 0, y: 0, z: 0 };

        let originalEmbeddings = [];
        let sharedParticles = [];

        const CIRCUIT_Y_OFFSET = 0.015;
        const PLANE_VERTICAL_SPACING = 2;
        const BOX_HEIGHT_HALF = 0.1;
        const COLLISION_BUFFER = 0.05;

        const BACKGROUND_COLOR = 0x0a0f1c;
        const PLANE_COLOR = 0x141928;

        const GRID_SIZE = 28;
        const SCALE_FACTOR = 0.1;
        const GRID_EXTENT = GRID_SIZE * SCALE_FACTOR;
        const CONTROL_BOUNDS = GRID_EXTENT * 2;

        class PRNG {
            constructor(seed) { this.seed = seed; }
            random() {
                this.seed ^= this.seed << 13;
                this.seed ^= this.seed >>> 17;
                this.seed ^= this.seed << 5;
                return (this.seed >>> 0) / 4294967296;
            }
        }

        const COLORS = {
            search: 0x5064ff,
            analysis: 0x80a0ff,
            data: 0xff6080,
            default: 0xffa060
        };

        const NODE_COLORS = [
            0x5064ff, 0x80a0ff, 0xff6080, 0xffa060, 0x60c0ff
        ];

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(BACKGROUND_COLOR);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, GRID_EXTENT * 2, GRID_EXTENT * 4);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = false;

            document.getElementById('canvas').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = GRID_EXTENT;
            controls.maxDistance = GRID_EXTENT * 10;
            controls.minPolarAngle = 0;
            controls.maxPolarAngle = Math.PI;
            controls.minAzimuthAngle = -Math.PI / 2;
            controls.maxAzimuthAngle = Math.PI / 2;
            controls.target.set(0, PLANE_VERTICAL_SPACING * 4, 0);

            controls.addEventListener('change', () => {
                if (cameraInitialized) {
                    lastCameraPosition.x = camera.position.x;
                    lastCameraPosition.y = camera.position.y;
                    lastCameraPosition.z = camera.position.z;
                    lastCameraTarget.x = controls.target.x;
                    lastCameraTarget.y = controls.target.y;
                    lastCameraTarget.z = controls.target.z;
                }
            });

            scene.add(new THREE.AmbientLight(0xe0e6ff, 0.6));

            const gridHelper = new THREE.GridHelper(GRID_EXTENT * 20, 50, 0x5064ff, 0x141928);
            gridHelper.position.y = -0.5;
            scene.add(gridHelper);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            document.getElementById('speed-slider').addEventListener('input', e => fallSpeed = parseInt(e.target.value));
            document.getElementById('glow-slider').addEventListener('input', e => {
                glowIntensity = parseInt(e.target.value);
                updateGlowIntensity();
            });
            document.getElementById('threshold-slider').addEventListener('input', e => {
                valueThreshold = parseInt(e.target.value) / 100;
                document.getElementById('threshold-value').textContent = valueThreshold.toFixed(2);
            });
            document.getElementById('pulse-checkbox').addEventListener('change', e => pulseEffect = e.target.checked);

            document.getElementById('threshold-value').textContent = valueThreshold.toFixed(2);
            document.getElementById('pulse-checkbox').checked = pulseEffect;

            animate();
        }

        function updateGlowIntensity() {
            embeddings.forEach(e => {
                if (e.illuminations) {
                    e.illuminations.forEach(illum => {
                        if (illum.material) {
                            illum.material.opacity = (illum.userData.baseOpacity || 0.5) * (glowIntensity / 7);
                        }
                    });
                }
                if (e.circuitNodes) {
                    Object.values(e.circuitNodes).forEach(node => {
                        if (node.isIlluminated && node.material) {
                            node.material.opacity = Math.min(0.9, 0.3 + node.userData.value * 0.6) * (glowIntensity / 7);
                        }
                    });
                }
            });
        }

        function checkCollision(particle, plane) {
            const planeY = plane.group.position.y;
            const particleY = particle.position.y;
            const particleHeightHalf = particle.userData.length / 2;
            const collisionPoint = planeY;

            const isColliding = particleY - particleHeightHalf <= collisionPoint + COLLISION_BUFFER &&
                               particleY - particleHeightHalf > collisionPoint - COLLISION_BUFFER &&
                               !particle.userData.collided[plane.gridIndex];

            return isColliding;
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            const time = performance.now() * 0.001;

            if (sharedParticles.length > 0) {
                const speed = 0.02 * fallSpeed;
                sharedParticles.forEach((p, i) => {
                    p.position.y -= speed * (1 + Math.sin(i * 0.1) * 0.2);

                    if (pulseEffect && p.material) {
                        p.material.opacity = 0.5 + Math.sin(time * 2 + i * 0.1) * 0.5;
                    }

                    embeddings.forEach((plane, planeIndex) => {
                        if (checkCollision(p, plane)) {
                            p.userData.collided[plane.gridIndex] = true;
                            const posX = p.userData.gridX;
                            const posZ = p.userData.gridZ;
                            const key = `${posX}_${posZ}`;
                            const scaleFactor = SCALE_FACTOR;
                            const positionX = (posX - GRID_SIZE / 2 + 0.5) * scaleFactor;
                            const positionZ = (posZ - GRID_SIZE / 2 + 0.5) * scaleFactor;

                            createIllumination(plane, key, positionX, positionZ, posX, posZ, p.userData.value, p.userData.color, time);
                            p.userData.completedPlanes++;
                        }
                    });

                    if (p.userData.completedPlanes >= embeddings.length || p.position.y < -15) {
                        p.position.y = 25 + Math.random() * 5;
                        p.visible = true;
                        p.userData.completedPlanes = 0;
                        p.userData.collided = embeddings.map(() => false);
                    }
                });
            }

            embeddings.forEach(e => {
                Object.keys(e.illumination).forEach(key => {
                    const illum = e.illumination[key];
                    const timeSince = time - illum.userData.lastActive;

                    if (timeSince > 0.1) {
                        illum.material.opacity *= 0.90;
                        if (illum.material.opacity < 0.05) {
                            e.group.remove(illum);
                            delete e.illumination[key];
                            e.illuminations = e.illuminations.filter(i => i !== illum);
                        }
                    }
                });

                if (e.networkTransition && e.networkTransition.length > 0) {
                    const now = performance.now();
                    const completedTransitions = [];

                    e.networkTransition.forEach((transition, index) => {
                        const elapsedMs = now - transition.startTime;
                        const duration = transition.duration;
                        const progress = Math.min(1, elapsedMs / duration);

                        if (transition.type === 'add') {
                            if (transition.node) {
                                transition.node.scale.set(progress, progress, progress);
                                transition.node.material.opacity = progress * (0.2 + transition.value * 0.3);
                                if (transition.lines) {
                                    transition.lines.forEach(line => line.material.opacity = progress * 0.2);
                                }
                            }
                            if (progress >= 1) completedTransitions.push(index);
                        } else if (transition.type === 'update' || transition.type === 'remove') {
                            if (transition.node) {
                                if (transition.type === 'update') {
                                    const newColor = new THREE.Color(transition.color);
                                    transition.node.material.color.lerp(newColor, progress);
                                    const newScale = 1 + transition.value * 0.5;
                                    transition.node.scale.set(
                                        transition.node.userData.originalScale * (1 - progress) + newScale * progress,
                                        transition.node.userData.originalScale * (1 - progress) + newScale * progress,
                                        transition.node.userData.originalScale * (1 - progress) + newScale * progress
                                    );
                                } else {
                                    transition.node.material.opacity = (1 - progress) * 0.5;
                                    transition.node.scale.set(1 - progress, 1 - progress, 1 - progress);
                                    if (transition.lines) {
                                        transition.lines.forEach(line => line.material.opacity = (1 - progress) * 0.2);
                                    }
                                }
                                if (progress >= 1) {
                                    if (transition.type === 'remove') {
                                        if (transition.node && transition.node.parent) transition.node.parent.remove(transition.node);
                                        if (transition.lines) {
                                            transition.lines.forEach(line => { if (line.parent) line.parent.remove(line); });
                                        }
                                    }
                                    completedTransitions.push(index);
                                }
                            }
                        }
                    });

                    completedTransitions.sort((a, b) => b - a).forEach(index => e.networkTransition.splice(index, 1));
                }

                if (e.circuits) {
                    e.circuits.forEach((circuit, i) => {
                        if (circuit.material && !circuit.isIlluminated) {
                            circuit.material.opacity = 0.2 + Math.sin(time * 0.5 + i * 0.1) * 0.1;
                        }
                    });
                }
            });

            renderer.render(scene, camera);
        }

        function createIllumination(plane, key, positionX, positionZ, gridX, gridZ, value, color, time) {
            const scaleFactor = SCALE_FACTOR;
            if (!plane.illumination[key]) {
                const illumGeo = new THREE.PlaneGeometry(scaleFactor * 0.9, scaleFactor * 0.9);
                const opacity = 0.5 + value * 0.5;
                const illumMat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: opacity * (glowIntensity / 7),
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending
                });

                const illum = new THREE.Mesh(illumGeo, illumMat);
                illum.rotation.x = -Math.PI / 2;
                illum.position.set(positionX, 0.01, positionZ);
                illum.userData = { lastActive: time, gridX, gridZ, value, baseOpacity: opacity };

                plane.group.add(illum);
                plane.illumination[key] = illum;
                plane.illuminations.push(illum);

                updateNetworkWithNewPoint(plane, gridX, gridZ, value, color);
            } else {
                plane.illumination[key].userData.lastActive = time;
                if (plane.circuitNodes[key]) {
                    const transition = {
                        type: 'update',
                        node: plane.circuitNodes[key],
                        startTime: performance.now(),
                        duration: 300,
                        value,
                        color
                    };
                    if (!plane.networkTransition) plane.networkTransition = [];
                    plane.networkTransition.push(transition);
                }
            }
        }

        function updateNetworkWithNewPoint(embedding, x, z, value, color) {
            const scaleFactor = SCALE_FACTOR;
            const positionX = (x - GRID_SIZE / 2 + 0.5) * scaleFactor;
            const positionZ = (z - GRID_SIZE / 2 + 0.5) * scaleFactor;
            const key = `${x}_${z}`;

            if (!embedding.networkTransition) embedding.networkTransition = [];

            const existingNode = embedding.circuitNodes[key];
            if (existingNode) {
                const transition = {
                    type: 'update',
                    node: existingNode,
                    startTime: performance.now(),
                    duration: 300,
                    value,
                    color
                };
                embedding.networkTransition.push(transition);
            } else {
                const nodeSize = 0.005 + value * 0.01;
                const node = new THREE.Mesh(
                    new THREE.CircleGeometry(nodeSize, 8),
                    new THREE.MeshBasicMaterial({
                        color,
                        transparent: true,
                        opacity: 0,
                        side: THREE.DoubleSide
                    })
                );

                node.position.set(positionX, 0, positionZ);
                node.rotation.x = -Math.PI / 2;
                node.scale.set(0, 0, 0);
                node.userData = { baseValue: value, gridX: x, gridZ: z, nodeColor: color, originalScale: 1.0 };

                embedding.circuitGroup.add(node);
                embedding.circuitNodes[key] = node;
                node.connectedLines = [];

                const connectedLines = connectToNearbyNodes(embedding, node, x, z, value, color);

                const transition = {
                    type: 'add',
                    node,
                    lines: connectedLines,
                    startTime: performance.now(),
                    duration: 400,
                    value
                };
                embedding.networkTransition.push(transition);

                embedding.circuits.push(node, ...connectedLines);

                const maxNodes = 150;
                const nodeKeys = Object.keys(embedding.circuitNodes);
                if (nodeKeys.length > maxNodes) {
                    const nodesToRemove = nodeKeys.slice(0, nodeKeys.length - maxNodes);
                    nodesToRemove.forEach(nodeKey => {
                        const nodeToRemove = embedding.circuitNodes[nodeKey];
                        if (nodeToRemove) {
                            const transition = {
                                type: 'remove',
                                node: nodeToRemove,
                                lines: nodeToRemove.connectedLines,
                                startTime: performance.now(),
                                duration: 1000
                            };
                            embedding.networkTransition.push(transition);
                            delete embedding.circuitNodes[nodeKey];
                        }
                    });
                }
            }
        }

        function connectToNearbyNodes(embedding, node, x, z, value, color) {
            const scaleFactor = SCALE_FACTOR;
            const positionX = (x - GRID_SIZE / 2 + 0.5) * scaleFactor;
            const positionZ = (z - GRID_SIZE / 2 + 0.5) * scaleFactor;
            const connectedLines = [];
            const maxConnections = 3;

            const nodeKeys = Object.keys(embedding.circuitNodes);
            const candidates = [];

            nodeKeys.forEach(key => {
                if (key === `${x}_${z}`) return;
                const otherNode = embedding.circuitNodes[key];
                const dx = otherNode.position.x - positionX;
                const dz = otherNode.position.z - positionZ;
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (distance < 0.7) {
                    candidates.push({ node: otherNode, distance });
                }
            });

            candidates.sort((a, b) => a.distance - b.distance);
            const connectionsToMake = Math.min(candidates.length, maxConnections);

            for (let i = 0; i < connectionsToMake; i++) {
                const otherNode = candidates[i].node;
                const line = new THREE.Line(
                    new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(positionX, 0, positionZ),
                        new THREE.Vector3(otherNode.position.x, 0, otherNode.position.z)
                    ]),
                    new THREE.LineBasicMaterial({
                        color: new THREE.Color(color).lerp(new THREE.Color(otherNode.userData.nodeColor), 0.5),
                        transparent: true,
                        opacity: 0
                    })
                );

                embedding.circuitGroup.add(line);
                connectedLines.push(line);
                node.connectedLines.push(line);
                otherNode.connectedLines.push(line);
            }

            return connectedLines;
        }

        function createSharedParticles(embedding) {
            sharedParticles.forEach(p => { if (p.parent) p.parent.remove(p); });
            sharedParticles = [];

            const particleGroup = new THREE.Group();
            scene.add(particleGroup);

            const gridWidth = GRID_SIZE;
            const gridHeight = GRID_SIZE;
            const scaleFactor = SCALE_FACTOR;

            embedding.significantValues.forEach(point => {
                const baseSize = scaleFactor * 0.9;
                const length = baseSize * (0.8 + point.value * 0.2);
                const geo = new THREE.BoxGeometry(baseSize, length, baseSize);

                const nodeColor = NODE_COLORS[(point.col * 5 + point.row * 3) % NODE_COLORS.length];
                const colorIntensity = 0.7 + point.value * 0.3;
                const elementColor = new THREE.Color(nodeColor).multiplyScalar(colorIntensity);

                const mat = new THREE.MeshBasicMaterial({
                    color: elementColor,
                    transparent: true,
                    opacity: 0.7 + point.value * 0.3
                });

                const particle = new THREE.Mesh(geo, mat);
                const posX = (point.col - GRID_SIZE / 2 + 0.5) * scaleFactor;
                const posZ = (point.row - GRID_SIZE / 2 + 0.5) * scaleFactor;
                particle.position.set(posX, 25 + Math.random() * 5, posZ);
                particle.userData = {
                    color: elementColor,
                    value: point.value,
                    gridX: point.col,
                    gridZ: point.row,
                    length,
                    completedPlanes: 0,
                    collided: embeddings.map(() => false)
                };

                particleGroup.add(particle);
                sharedParticles.push(particle);

                const glowMat = new THREE.SpriteMaterial({
                    map: createGlowTexture(elementColor),
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    opacity: 0.3
                });

                const glow = new THREE.Sprite(glowMat);
                glow.scale.set(scaleFactor, length * 2, 1);
                particle.add(glow);
            });

            return particleGroup;
        }

        function createMatrixViz(x, y, z, embedding, type, index) {
            const group = new THREE.Group();
            group.position.set(x, y, z);

            const illumination = {};
            const illuminations = [];
            const circuits = [];
            const circuitNodes = {};

            const gridWidth = GRID_SIZE;
            const gridHeight = GRID_SIZE;
            const scaleFactor = SCALE_FACTOR;
            const color = COLORS[type] || COLORS.default;

            const baseSize = gridWidth * scaleFactor;
            const baseGeo = new THREE.PlaneGeometry(baseSize, baseSize);
            const baseMat = new THREE.MeshBasicMaterial({
                color: PLANE_COLOR,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });

            const base = new THREE.Mesh(baseGeo, baseMat);
            base.rotation.x = -Math.PI / 2;
            base.position.set(0, 0, 0);
            group.add(base);

            const gridHelper = new THREE.GridHelper(baseSize, gridWidth, 0x5064ff, 0x0a0f1c);
            gridHelper.position.y = 0.01;
            gridHelper.position.x = 0;
            gridHelper.position.z = 0;
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            group.add(gridHelper);

            const circuitGroup = new THREE.Group();
            circuitGroup.position.y = CIRCUIT_Y_OFFSET;
            group.add(circuitGroup);

            const initialNetworkEmbedding = createInitialNetworkEmbedding(index);
            const networkSignificantValues = [];
            initialNetworkEmbedding.forEach((val, i) => {
                if (val > valueThreshold) {
                    const col = i % gridWidth;
                    const row = Math.floor(i / gridWidth);
                    networkSignificantValues.push({
                        index: i,
                        value: val,
                        col,
                        row,
                        x: (col - gridWidth / 2 + 0.5) * scaleFactor,
                        z: (row - gridHeight / 2 + 0.5) * scaleFactor
                    });
                }
            });

            const circuitData = addInitialNetworkPatterns(circuitGroup, color, baseSize, networkSignificantValues, scaleFactor, circuitNodes, type);
            circuits.push(...circuitData.circuits);

            const significantValues = [];
            embedding.forEach((val, i) => {
                if (val > valueThreshold) {
                    const col = i % gridWidth;
                    const row = Math.floor(i / gridWidth);
                    significantValues.push({
                        index: i,
                        value: val,
                        col,
                        row,
                        x: (col - gridWidth / 2 + 0.5) * scaleFactor,
                        z: (row - gridHeight / 2 + 0.5) * scaleFactor
                    });
                }
            });

            const networkTransition = [];
            scene.add(group);
            return { group, type, illumination, illuminations, circuits, circuitGroup, circuitNodes, networkTransition, gridIndex: index, embedding: embedding.slice(), significantValues: significantValues.slice() };
        }

        function createInitialNetworkEmbedding(seed) {
            const rng = new PRNG(seed + 12345);
            const embedding = new Array(GRID_SIZE * GRID_SIZE).fill(0);

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const i = y * GRID_SIZE + x;
                    let val = 0;

                    if (seed % 3 === 0) {
                        if ((x % 4 === 0) || (y % 4 === 0)) val = 0.3 + rng.random() * 0.4;
                    } else if (seed % 3 === 1) {
                        const dx = x - GRID_SIZE / 2;
                        const dy = y - GRID_SIZE / 2;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 10) val = (1 - dist / 10) * (0.3 + rng.random() * 0.5);
                    } else {
                        if (Math.abs((x + y) % 8) < 2) val = 0.3 + rng.random() * 0.4;
                    }

                    if (rng.random() < 0.05) val = 0.3 + rng.random() * 0.5;
                    embedding[i] = val;
                }
            }

            return embedding;
        }

        function addInitialNetworkPatterns(circuitGroup, color, baseSize, significantValues, scaleFactor, circuitNodes, type) {
            const circuits = [];

            significantValues.forEach(point => {
                const key = `${point.col}_${point.row}`;
                const nodeColor = NODE_COLORS[(point.col * 3 + point.row * 7) % NODE_COLORS.length];
                const nodeSize = 0.005 + point.value * 0.01;

                const node = new THREE.Mesh(
                    new THREE.CircleGeometry(nodeSize, 8),
                    new THREE.MeshBasicMaterial({
                        color: nodeColor,
                        transparent: true,
                        opacity: 0.2 + point.value * 0.3,
                        side: THREE.DoubleSide
                    })
                );

                node.position.set(point.x, 0, point.z);
                node.rotation.x = -Math.PI / 2;
                node.userData = { baseValue: point.value, gridX: point.col, gridZ: point.row, nodeColor, originalNodeColor: nodeColor, originalScale: 1.0, initial: true };

                circuitGroup.add(node);
                circuits.push(node);
                circuitNodes[key] = node;
                node.connectedLines = [];
            });

            const maxConnections = 3;
            const maxDistance = 0.7;

            significantValues.forEach((pointA, idxA) => {
                const connections = [];
                const keyA = `${pointA.col}_${pointA.row}`;

                significantValues.forEach((pointB, idxB) => {
                    if (idxA === idxB) return;
                    const distance = Math.sqrt(Math.pow(pointA.x - pointB.x, 2) + Math.pow(pointA.z - pointB.z, 2));
                    if (distance < maxDistance) connections.push({ point: pointB, distance });
                });

                connections.sort((a, b) => a.distance - b.distance);
                const connectionsToMake = Math.min(connections.length, maxConnections);

                for (let i = 0; i < connectionsToMake; i++) {
                    const pointB = connections[i].point;
                    const keyB = `${pointB.col}_${pointB.row}`;
                    const idxMin = Math.min(idxA, connections[i].point.index);
                    const idxMax = Math.max(idxA, connections[i].point.index);
                    const connectionKey = `${idxMin}_${idxMax}`;

                    if (circuits[connectionKey]) continue;

                    const nodeColorA = circuitNodes[keyA].userData.nodeColor;
                    const nodeColorB = circuitNodes[keyB].userData.nodeColor;
                    const lineColor = new THREE.Color(nodeColorA).lerp(new THREE.Color(nodeColorB), 0.5);

                    const line = new THREE.Line(
                        new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(pointA.x, 0, pointA.z),
                            new THREE.Vector3(pointB.x, 0, pointB.z)
                        ]),
                        new THREE.LineBasicMaterial({
                            color: lineColor,
                            transparent: true,
                            opacity: 0.2 + 0.2 * Math.min(pointA.value, pointB.value)
                        })
                    );

                    line.userData = { initial: true };
                    circuitGroup.add(line);
                    circuits.push(line);

                    if (circuitNodes[keyA]) circuitNodes[keyA].connectedLines.push(line);
                    if (circuitNodes[keyB]) circuitNodes[keyB].connectedLines.push(line);

                    circuits[connectionKey] = true;
                }
            });

            return { circuits, circuitNodes };
        }

        function createGlowTexture(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            const colorHex = '#' + new THREE.Color(color).getHexString();

            gradient.addColorStop(0, colorHex);
            gradient.addColorStop(0.5, colorHex.replace(')', ', 0.5)').replace('rgb', 'rgba'));
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);

            return new THREE.CanvasTexture(canvas);
        }

        function visualize() {
            const loading = document.getElementById('loading');
            loading.style.display = 'flex';
            loading.style.opacity = '1';
            document.getElementById('loading-progress').textContent = 'Parsing stream...';

            if (cameraInitialized) {
                lastCameraPosition.x = camera.position.x;
                lastCameraPosition.y = camera.position.y;
                lastCameraPosition.z = camera.position.z;
                lastCameraTarget.x = controls.target.x;
                lastCameraTarget.y = controls.target.y;
                lastCameraTarget.z = controls.target.z;
            }

            setTimeout(() => {
                const input = document.getElementById('embedding-input').value;
                const data = input.split('\n').map(line => {
                    try { return JSON.parse(line.trim()); } 
                    catch (e) { console.error("Parse fail:", e); return null; }
                }).filter(d => d && d.embedding);

                document.getElementById('loading-progress').textContent = 'Wiping old data...';

                sharedParticles.forEach(p => { if (p.parent) p.parent.remove(p); });
                sharedParticles = [];

                embeddings.forEach(e => scene.remove(e.group));
                embeddings = [];
                originalEmbeddings = [];

                const positions = [
                    [0, 0, 0], [0, PLANE_VERTICAL_SPACING, 0], [0, PLANE_VERTICAL_SPACING * 2, 0],
                    [0, PLANE_VERTICAL_SPACING * 3, 0], [0, PLANE_VERTICAL_SPACING * 4, 0],
                    [0, PLANE_VERTICAL_SPACING * 5, 0], [0, PLANE_VERTICAL_SPACING * 6, 0],
                    [0, PLANE_VERTICAL_SPACING * 7, 0], [0, PLANE_VERTICAL_SPACING * 8, 0]
                ];

                data.slice(0, 9).forEach((d, i) => {
                    document.getElementById('loading-progress').textContent = `Building viz ${i+1}/${Math.min(9, data.length)}...`;
                    const embedding = createMatrixViz(...positions[i], d.embedding, d.type || 'default', i);
                    embeddings.push(embedding);
                    originalEmbeddings.push({ embedding: d.embedding.slice(), type: d.type || 'default' });
                });

                if (data.length < 9) {
                    for (let i = data.length; i < 9; i++) {
                        document.getElementById('loading-progress').textContent = `Filling default viz ${i+1}/9...`;
                        const defaultEmbedding = Array(768).fill(0).map(() => Math.random());
                        const embedding = createMatrixViz(...positions[i], defaultEmbedding, 'default', i);
                        embeddings.push(embedding);
                        originalEmbeddings.push({ embedding: defaultEmbedding.slice(), type: 'default' });
                    }
                }

                if (embeddings.length > 0) {
                    document.getElementById('loading-progress').textContent = 'Spawning particles...';
                    createSharedParticles(embeddings[0]);
                }

                updateStats(data);

                if (cameraInitialized) {
                    camera.position.set(lastCameraPosition.x, lastCameraPosition.y, lastCameraPosition.z);
                    controls.target.set(lastCameraTarget.x, lastCameraTarget.y, lastCameraTarget.z);
                } else {
                    const centerY = embeddings.length > 1 ? (PLANE_VERTICAL_SPACING * (embeddings.length - 1)) / 2 : 0;
                    camera.position.set(0, centerY + GRID_EXTENT * 2, GRID_EXTENT * 4);
                    controls.target.set(0, centerY, 0);
                    lastCameraPosition.x = 0;
                    lastCameraPosition.y = centerY + GRID_EXTENT * 2;
                    lastCameraPosition.z = GRID_EXTENT * 4;
                    lastCameraTarget.x = 0;
                    lastCameraTarget.y = centerY;
                    lastCameraTarget.z = 0;
                    cameraInitialized = true;
                }

                controls.update();
                loading.style.opacity = '0';
                setTimeout(() => loading.style.display = 'none', 500);
            }, 300);
        }

        function shootNewParticles() {
            if (embeddings.length === 0) return;

            const loading = document.getElementById('loading');
            loading.style.display = 'flex';
            loading.style.opacity = '1';
            document.getElementById('loading-progress').textContent = 'Reloading particles...';

            setTimeout(() => {
                if (embeddings.length > 0) {
                    document.getElementById('loading-progress').textContent = 'Firing new batch...';
                    createSharedParticles(embeddings[0]);
                }
                loading.style.opacity = '0';
                setTimeout(() => loading.style.display = 'none', 500);
            }, 300);
        }

        function resetView() {
            const centerY = embeddings.length > 1 ? (PLANE_VERTICAL_SPACING * (embeddings.length - 1)) / 2 : 0;
            camera.position.set(0, centerY + GRID_EXTENT * 2, GRID_EXTENT * 4);
            controls.target.set(0, centerY, 0);
            controls.update();

            lastCameraPosition.x = 0;
            lastCameraPosition.y = centerY + GRID_EXTENT * 2;
            lastCameraPosition.z = GRID_EXTENT * 4;
            lastCameraTarget.x = 0;
            lastCameraTarget.y = centerY;
            lastCameraTarget.z = 0;
        }

        function generateSample() {
            const types = ['search', 'analysis', 'data', 'default', 'search', 'analysis', 'data', 'default', 'search'];
            const data = [];

            for (let i = 0; i < 9; i++) {
                const embedding = Array(768).fill().map((_, idx) => {
                    const x = idx % GRID_SIZE;
                    const y = Math.floor(idx / GRID_SIZE);
                    let val = 0;

                    if (i % 3 === 0) {
                        const centerX = GRID_SIZE / 2, centerY = GRID_SIZE / 2;
                        const dist = Math.sqrt((x - centerX) * (x - centerX) + (y - centerY) * (y - centerY));
                        val = Math.sin(dist * 0.5) * 0.5 + 0.5;
                        val = Math.round(val * 5) / 5;
                    } else if (i % 3 === 1) {
                        val = ((x % 4 < 2) && (y % 4 < 2)) ? 0.8 : 0.2;
                        if ((x === y) || (x + y === GRID_SIZE - 1)) val = 0.9;
                    } else {
                        const points = [{ x: 7, y: 7 }, { x: 21, y: 7 }, { x: 14, y: 21 }, { x: 7, y: 21 }, { x: 21, y: 21 }];
                        let minDist = Infinity;
                        for (const p of points) {
                            const d = Math.sqrt((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y));
                            minDist = Math.min(minDist, d);
                        }
                        val = 1 - Math.min(minDist / 10, 1);
                        val = Math.round(val * 4) / 4;
                    }

                    val = Math.min(1, Math.max(0, val + (Math.random() - 0.5) * 0.1));
                    return Math.random() < val ? val : 0;
                });

                data.push({ type: types[i], embedding });
            }

            document.getElementById('embedding-input').value = data.map(d => JSON.stringify(d)).join('\n');
            visualize();
        }

        function updateStats(data) {
            const stats = document.getElementById('stats');
            stats.innerHTML = data.map(d => {
                const e = d.embedding;
                const avg = e.reduce((s, v) => s + v, 0) / e.length;
                const min = Math.min(...e);
                const max = Math.max(...e);
                const significant = e.filter(v => v > valueThreshold).length;

                return `<div class="mb-2">
                    <div class="font-bold code-text">[${d.type.toUpperCase()}]</div>
                    <div>MIN: ${min.toFixed(2)} | MAX: ${max.toFixed(2)}</div>
                    <div>AVG: ${avg.toFixed(2)} | SIG: ${significant}</div>
                    <div class="mt-1">PWR: ${Math.round(significant / 768 * 100)}%</div>
                </div>`;
            }).join('');
        }

        window.addEventListener('load', () => {
            init();

            document.getElementById('visualize-btn').addEventListener('click', visualize);
            document.getElementById('reset-btn').addEventListener('click', resetView);
            document.getElementById('generate-sample').addEventListener('click', generateSample);
            document.getElementById('shoot-btn').addEventListener('click', shootNewParticles);

            document.getElementById('sample-toggle').addEventListener('click', () => {
                const panel = document.getElementById('sample-panel');
                const icon = document.getElementById('toggle-icon');
                panel.classList.toggle('hidden');
                icon.textContent = panel.classList.contains('hidden') ? '▾' : '▴';
            });

            document.getElementById('settings-toggle').addEventListener('click', () => {
                const panel = document.getElementById('settings-panel');
                const icon = document.getElementById('settings-icon');
                panel.classList.toggle('hidden');
                icon.textContent = panel.classList.contains('hidden') ? '▾' : '▴';
            });

            setTimeout(() => {
                generateSample();
                document.getElementById('loading').style.opacity = '0';
                setTimeout(() => document.getElementById('loading').style.display = 'none', 500);
            }, 1000);
        });
    </script>
</body>
</html>
